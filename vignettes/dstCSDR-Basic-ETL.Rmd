---
title: "{dstCSDR} Basic ETL Pipeline"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dstCSDR-Basic-ETL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dstCSDR)
library(tidyverse, quietly = TRUE)
library(gt)
```

The basic `{dstCSDR}` ETL pipeline lets you import, tidy, and (optionally) return the data back to Excel for further review and processing.  The package comes with some example CSDR files included which we will use in this vignette.  

We can see a list of those example CSDR files using the `dstCSDR_files()` function.

```{r print-example-files}
dstCSDR_files()
```

If we pass `dstCSDR_files()` the name of one of those files, it will give us back a full path to where that file is on our system (this will be helpful in a minute when we import these).  

```{r print-path-to-one-example-file}
dstCSDR_files("Example_CDSR_1921.xls")
```

# On the Agenda

In this vignette, we will:  

1.  import an example CSDR (DD Form 1921) and FCHR (DD Form 1921-1) into R,  
2.  we will tidy the FCHR (DD Form 1921-1),  
3.  return that data to Excel for further processing.

# 1. Importing CSDR Data

## Import Function Overview

The `{dstCSDR}` package takes a tip from tidyverse packages and utilizes a consistent naming convention when it comes to working with CSDR data.  

Import functions always begin with `import_...` then the type of CSDR deliverable it will import, for example:  

* `import_cdsr_...() # Imports a CDSR (DD Form 1921) file (from a yet unknown file type)`
* `import_fchr_...() # Imports a FCHR (DD Form 1921-1) file (from a yet unknown file type)`

Finally the function names end with the type of file you are importing that CSDR data from, for example:  

* `import_cdsr_excel() # Imports a CDSR (DD Form 1921) from a source Excel file`
* `import_fchr_xml() # Imports a FCHR (DD Form 1921-1) from a source XML file`

You then pass the functions the full path (including file name and extension) to where the CSDR file resides on your system, ShareDrive, or network connection.  (The below code won't actually run since this location does not actually exist, but hopefully you get the point.)  

```{r import-direct-path, eval=FALSE, include=TRUE}
import_cdsr_excel("C:/Users/john.doe/Documents/CDSR.xls")
```

You could also use `file.choose()` which will create a popup box that you can use to navigate to your file.  

```{r import-with-file.choose, eval=FALSE, include=TRUE}
import_cdsr_excel(file.choose())
```

## Import Function Examples

Let's import the CDSR and FCHR from the example Excel files provided with the package.  

```{r import-cdsr-and-fchr}
cdsr <- import_cdsr_excel(dstCSDR_files("Example_CDSR_1921.xls"))
fchr <- import_fchr_excel(dstCSDR_files("Example_FCHR_1921_1.xls"))
```

This created two new objects in your Global Environment:

* `cdsr` includes the data found in the `Example_CDSR_1921.xls` file.
* `fchr` includes the data found in the `Example_FCHR_1921_1.xls` file.

Note that the `dstCSDR_files()` function we used above returned the complete file path for each file since we included the file name (with extension) in the `dstCSDR_files()` function call.  If you wanted to import your own data, you would replace "`dstCSDR_files("...")`" with a direct path to your file.

## Review of the Imported CSDR Objects 

Now that we have imported those files into the `cdsr` and `fchr` objects, what did we actually get?  

`{dstCSDR}` imports CSDRs into list objects where the list (normally) includes one tibble for each major block of data included in any given CSDR deliverable?  

> What does that mean?  

Fair question.  Let's look at the first level of the `cdsr` object as an example.

```{r str-level-1-cdsr}
str(cdsr, max.level = 1)
```

Above we can see that `cdsr` is comprised of three named tables:
* `metadata`: Includes the CSDR submission metadata found at the top of the legacy forms.  
* `reported_data`: Includes reported costs by WBS element (the middle section of the legacy CDSR form).  
* `summary_reporting_elements`: Includes the summary elements like G&A and fee which are not directly attributable to any one WBS element (the bottom of the legacy CDSR form).  

Here is each of those three tables, one at a time (using `kable()` to print them since that looks nicer than `print()` in HTML):  

## `metadata`

```{r kable-metadata}
cdsr[["metadata"]] %>% 
  gt() %>% 
  tab_options(column_labels.font.size = 11, table.font.size = 11)
```

## `reported_data`

```{r kable-reported-data}
cdsr[["reported_data"]] %>%
  gt() %>% 
  tab_options(column_labels.font.size = 11, table.font.size = 11) %>% 
   fmt_currency(columns = starts_with("Costs"),
                accounting = TRUE,
                decimals = 1,
                locale = "en_US")
```

## `summary_reporting_elements`

```{r kable-summary_reporting_elements}
cdsr[["summary_reporting_elements"]] %>%
  gt() %>% 
  tab_options(column_labels.font.size = 11, table.font.size = 11) %>% 
  fmt_currency(columns = starts_with("Costs"),
               accounting = TRUE,
               decimals = 1,
               locale = "en_US") 
```

The `fchr` object follows the same pattern:  

```{r str-level-1-fchr}
str(fchr, max.level = 1)
```

In fact, the `metadata` object in both `cdsr` and `fchr` will match exactly (assuming the submitter entered the same metadata).

# 2. Tidying the `fchr` Data

The `{dstCSDR}` package imports the CSDR data so that the initial tables look similar to the original CSDR forms.  Those CSDR forms are human readable but that format is not particularly conducive to exploratory data analysis (EDA) or use in R (or even Excel).  

The `gather_fchr()` and `add_supplemental_fchr_columns()` functions transform the CSDR data from its original format to a tidy/pivot friendly flat file format and combines the reported cost & hours data with reported metadata.  The result is FCHR data in a format that is easier to work with both on its own or with multiple submissions (or multiple program's data) at once.  

Before being transformed, the first few rows of the `fchr` reported data look like this:

```{r native-fchr}
fchr[["reported_data"]] %>%
  head() %>% 
  gt() %>% 
  tab_options(column_labels.font.size = 11, table.font.size = 11) %>% 
  fmt_number(columns = starts_with("Costs and"),
             decimals = 1,
             rows = `Unit of Measure` == "Hours") %>% 
   fmt_currency(columns = starts_with("Costs and"),
                rows = `Unit of Measure` == "TY $K",
                accounting = TRUE,
                decimals = 1,
                locale = "en_US") 
```

That data is very wide (so wide, it likely did not even print very well on your screen).  

The `gather_fchr()` takes the all the "Cost and Hours..." columns and moves them down and two the left so that each row in the new table gives just one record of cost or hours data (vs. seven columns of data like the default `fchr` data).  Here is what that same data looks like after we run it though `gather_fchr()`:  

```{r gathered-fchr}
fchr %>%
  gather_fchr() %>%
  .[["reported_data"]] %>%
  head() %>%
  gt() %>%
  tab_options(column_labels.font.size = 11, table.font.size = 11) %>%
  fmt_number(columns = "Reported Data Value",
             decimals = 1,
             rows = `Unit of Measure` == "Hours") %>% 
   fmt_currency(columns = "Reported Data Value",
                rows = `Unit of Measure` == "TY $K",
                accounting = TRUE,
                decimals = 1,
                locale = "en_US") 
  
```

A close look at the code in the last chunk compared to those that came before revales two notable points:  

1. In all prior chunks, the second list object `"reported_data"` was specified before we printed something but in the last chunk, the whole `fchr` object was passed to `gather_fchr()`.  This is because `gather_fchr()` is expecting to be passed the whole `fchr`, not just the `"reported data"`.  

2. 

Now we have the data in a tall (rather than wide) table which is ready to work with via a pivot table or 
